import '/z3'

# atom = int
lit, nab, pp_lit = lit, nab, pp_lit where
  memo = {}
  strs = []
  # lit : string -> atom
  lit = s ->
    if not (s in memo) =>
      memo!!s := len strs
      strs.append s
    memo!!s
  # nab(la) : unit -> fresh atom
  nab = ->
    n = len strs
    strs.append ("'" + str n)
    n
  # pp_lit : atom -> str
  pp_lit = n -> if (n < len strs => strs!!n) (otherwise => "'" + str n)

# fresh unification variable
Var = subclass object where
  __init__ = self ->
    self.a = self # initially a self-loop
    None

# constraint
SMT = subclass object where
  __init__ = self a ->
    self.a = a
    None

# log = mutable list of thunks that will undo destructive updates (aka trail)
# solver = SMT solver
# f : action = log, solver -> generator of None
run = f ->
  log = []
  solver = z3.Solver!
  g = f log solver
  next g # force at least one success
  log, solver, g

# unify : term, term -> action
unify = l r -> log solver -> (
  except
    err => yield unify_ log solver l r nop nop
    err :: No => None
) where
  No = subclass Exception where
  nop = _ -> None
  # set_l x stores x in l's parent location
  #   i.e. pointer graph goes (p -> l) x ==set_l x==> (p -> x) l
  #   l isn't destroyed, but just isolated from the old reference graph
  unify_ = log solver l r set_l set_r ->
    # helpers
    set_var = v -> x -> v.a := x
    set_arr = arr i -> x -> arr!!i := x
    inst = v e ->
      log.append (-> (set_var v) v)
      v.a := e
    cyc = v e set_e ->
      log.append (-> set_e e)
      set_e v
      go v.a e (set_var v) nop
    go = l r set_l set_r -> if
      # simple cases
      l is r => None
      type l is type r is int and l == r => None
      type l is type r is list and len l == len r =>
        for (i, (x, y)) in enumerate (zip l r) =>
          go x y (set_arr l i) (set_arr r i)
      # instantiate variables
      type l is Var and l is l.a => inst l r
      type r is Var and r is r.a => inst r l
      # follow var -> var links (find representative)
      type l is Var is type l.a => go l.a r (set_var l) set_r
      type r is Var is type r.a => go r.a l (set_var r) set_l
      # var ~ non-var with var -> term:
      # - store var in non-var's parent pointer location
      # - check term ~ non-var
      # this allows for unification of cyclic structures
      type l is Var => cyc l r set_r
      type r is Var => cyc r l set_l
      # smt ~ smt: add equality constraint and check sat
      type l is type r is SMT =>
        solver.add (l.a == r.a)
        if solver.check() != z3.sat => raise No
      otherwise => raise No
    go l r set_l set_r

# revert all actions taken from log[n] onwards
undo = log n -> while len log > n => log.pop! !

# add : z3 formula .. -> action
add = *:fs -> log solver ->
  solver.add *:fs
  if solver.check! == z3.sat => yield None

# conj : action .. -> action
conj = *:fs -> log solver -> go fs where
  go = fs -> if
    len fs == 0 => yield None
    otherwise =>
      f, *fs = fs
      n = len log
      for _ in f log solver =>
        solver.push!
        yield from go fs
        undo log n
        solver.pop!

# disj : action .. -> action
disj = *:fs -> log solver ->
  n = len log
  for f in fs =>
    solver.push!
    yield from f log solver
    undo log n
    solver.pop!

# program = term -> action
# trace : program -> program
trace = f -> t ->
  print (zonk t)
  f t

# expand out non-cyclic uvars
zonk = t verbose:False -> go t where
  done = set!
  go = t -> if
    type t is int => pp_lit t
    type t is Var and t in done => hex (id t)
    type t is Var =>
      done.add t
      if (verbose => (hex (id t), go t.a)) (otherwise => go t.a)
    type t is list => list (map go t)
    type t is SMT => str t.a
    otherwise => raise ValueError ("Can't zonk " + str(t))

pp_zonked = t -> if
  type t is str => t
  otherwise => '[' + ' '.join(map pp_zonked t) + ']'

arr = *:ts ->
  res, *ts = ts
  while ts != [] =>
    h, *ts = ts
    res = [res, h]
  res

# appending (potentially infinite) lists
test_app = ->
  # nil ++ XS = XS
  # (X :: XS) ++ YS = (X :: ZS) <== XS ++ YS = ZS
  eq = lit '='
  app = lit '++'
  nil = lit 'nil'
  cons = h t -> arr h (lit '::') t
  go = t -> log solver ->
    base = unify t (arr nil app xs eq xs) where xs = Var!
    ind = (
      conj
        (unify t (arr (cons x xs) app ys eq (cons x zs)))
        (go (arr xs app ys eq zs))
    ) where x, xs, ys, zs = Var!, Var!, Var!, Var!
    (disj base ind) log solver
  # ('100 :: ('101 :: nil)) ~ XS
  xs = Var!
  log, _, _ = run (unify (cons 100 (cons 101 nil)) xs)
  print (pp_zonked (zonk xs))
  undo log 0
  print (pp_zonked (zonk xs))
  print!
  # XS ~ ('100 :: XS)
  # YS ~ ('100 :: (Z :: YS))
  # ZS ~ YS
  # ----------------------
  # Z ~ 100
  # YS ~ ('100 :: XS)
  xs, ys, z = Var!, Var!, Var!
  print (pp_zonked (zonk xs)) (pp_zonked (zonk ys)) (pp_zonked (zonk z))
  log, _, _ = run (conj
    (unify xs (cons 100 xs))
    (unify ys (cons 100 (cons z ys)))
    (unify xs ys))
  print (pp_zonked (zonk xs)) (pp_zonked (zonk ys)) (pp_zonked (zonk z))
  undo log 0
  print (pp_zonked (zonk xs)) (pp_zonked (zonk ys)) (pp_zonked (zonk z))
  print!
  # XS ~ ('100 :: ('100 :: XS))
  # YS ~ ('100 :: ('100 :: ('100 :: ZS)))
  # ZS ~ ('100 :: YS)
  # XS ~ YS
  xs, ys, zs = Var!, Var!, Var!
  print (pp_zonked (zonk xs)) (pp_zonked (zonk ys)) (pp_zonked (zonk zs))
  log, _, _ = run (conj
    (unify xs (cons 100 (cons 100 xs)))
    (unify ys (cons 100 (cons 100 (cons 100 zs))))
    (unify zs (cons 100 ys))
    (unify xs ys))
  print (pp_zonked (zonk xs)) (pp_zonked (zonk ys)) (pp_zonked (zonk zs))
  undo log 0
  print (pp_zonked (zonk xs)) (pp_zonked (zonk ys)) (pp_zonked (zonk zs))
  print!
  # (98 :: (99 :: nil)) ++ (100 :: (101 :: nil)) = (98 :: XS)
  # ---------------------------------------------------------
  # XS ~ (99 :: (100 :: (101 :: nil)))
  xs = Var!
  print (pp_zonked (zonk xs))
  log, _, _ = run (go
    (arr (cons 98 (cons 99 nil)) app (cons 100 (cons 101 nil)) eq (cons 98 xs)))
  print (pp_zonked (zonk xs))
  undo log 0
  print (pp_zonked (zonk xs))
  print!
  # (100 :: nil) ++ XS = XS
  # -----------------------
  # XS ~ (100 :: XS)
  xs = Var!
  print (pp_zonked (zonk xs))
  log, _, _ = run (go (arr (cons 100 nil) app xs eq xs))
  print (pp_zonked (zonk xs))
  undo log 0
  print (pp_zonked (zonk xs))
  print!

# basic backtracking to find more solutions
test_conj_back = ->
  # q a. q b. r c. r d.
  # p X Y <== q X, r Y.
  go = t -> log solver ->
    (disj
      (unify t (arr (lit 'q') (lit 'a')))
      (unify t (arr (lit 'q') (lit 'b')))
      (unify t (arr (lit 'r') (lit 'c')))
      (unify t (arr (lit 'r') (lit 'd')))
      ((conj
        (unify t (arr (lit 'p') x y))
        (go (arr (lit 'q') x))
        (go (arr (lit 'r') y))
      ) where x, y = Var!, Var!)
    ) log solver
  # p X Y ==>
  #   X ~ a, Y = c;
  #   X ~ a, Y = d;
  #   X ~ b, Y = c;
  #   X ~ b, Y = d
  x, y = Var!, Var!
  print (pp_zonked (zonk x)) (pp_zonked (zonk y))
  log = []
  for _ in (go (arr (lit 'p') x y)) log z3.Solver! =>
    print (pp_zonked (zonk x)) (pp_zonked (zonk y))
  print (pp_zonked (zonk x)) (pp_zonked (zonk y))
  print!

# constraint solving
test_smt = ->
  # fac 0 = 1.
  # fac {N + 1} = P <== {N >= 0}, {(N + 1) * M = P}, fac N = M.
  go = t -> log solver ->
    (disj
      (unify t (arr (lit 'fac') (SMT 0) (lit '=') (SMT 1)))
      ((conj
        (unify t (arr (lit 'fac') (SMT (n.a + 1)) (lit '=') p))
        (add (n.a >= 0))
        (add ((n.a + 1) * m.a == p.a))
        (go (arr (lit 'fac') n (lit '=') m))
      ) where n, m, p = SMT (z3.Int nab!), SMT (z3.Int nab!), SMT (z3.Int nab!))
    ) log solver
  # fac 100! X
  # ----------
  # {X = 100!}
  x = SMT (z3.Int 'x')
  log = []
  solver = z3.Solver!
  for _ in (go (arr (lit 'fac') (SMT 100) (lit '=') x)) log solver =>
    print solver solver.check! 'x ='
      (if (solver.check! == z3.sat => solver.model! !! x.a) (otherwise => None))
  print solver
  print!
  # fac X 720
  # ---------
  #   X = 7
  x = SMT (z3.Int 'x')
  log = []
  solver = z3.Solver!
  for _ in (go (arr (lit 'fac') x (lit '=') (SMT (720*7)))) log solver =>
    print solver solver.check! 'x ='
      (if (solver.check! == z3.sat => solver.model! !! x.a) (otherwise => None))
  print solver
  print!
  # enumerating all solutions to constraints
  # pythag A B C N <==
  #   {0 < A}, {A <= B}, {B <= C}, {C <= N}
  #   {A^2 + B^2 = C^2}.
  go = t ->
    a, b = SMT (z3.Int nab!), SMT (z3.Int nab!)
    c, n = SMT (z3.Int nab!), SMT (z3.Int nab!)
    conj
      (unify t (arr (lit 'pythag') a b c n))
      (add (0 < a.a) (a.a <= b.a) (b.a <= c.a) (c.a <= n.a) (a.a**2 + b.a**2 == c.a**2))
  a = SMT (z3.Int 'a')
  b = SMT (z3.Int 'b')
  c = SMT (z3.Int 'c')
  log = []
  solver = z3.Solver!
  for _ in (go (arr (lit 'pythag') a b c (SMT 30))) log solver =>
    solver.push!
    while solver.check! == z3.sat =>
      m = solver.model!
      ma, mb, mc = m !! a.a, m !! b.a, m !! c.a
      print 'a =' ma 'b =' mb 'c =' mc
      solver.add (z3.Not (z3.And (a.a == ma) (b.a == mb) (c.a == mc)))
    solver.pop!
  print!
  # cbrt {N * N * N} = N.
  go = t ->
    n = SMT (z3.Int nab!)
    conj (unify t (arr (lit 'cbrt') (SMT (n.a*n.a*n.a)) (lit '=') n))
  n = SMT (z3.Int 'n')
  log = []
  solver = z3.Solver!
  for _ in (go (arr (lit 'cbrt') (SMT (2019*2019*2019)) (lit '=') n)) log solver =>
    solver.push!
    while solver.check! == z3.sat =>
      m = solver.model!
      mn = m !! n.a
      print 'n =' mn
      solver.add (n.a != mn)
    solver.pop!
  print!

main = ->
  test_app!
  test_conj_back!
  test_smt!

main!
