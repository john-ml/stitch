Overhead per heap item in each size class:
  uint64_t W
  uint64_t[W/64] bitmap encoding the locations of pointers
    Needed for uniform traversal of sources
  Maybe (nat, nat) representing a 'level'
  Source next_ptr | Sink next_ptr
  Free next_ptr

Global overhead:
  [nat] 'cursor' representing 'current position' in call tree
  Deque of sources for tracing
  Stack of sinks for deallocation

On
  Bind lvalue that won't alias downward-escaping values: no-op
  Bind lvalue that might alias downward-escaping values:
    Enqueue source and 'remove' from sinks (set Source tag)
    If already in source, update level
  Value's lifetime ends:
    Push sink and 'remove' from sources (set Sink tag)
    If already in sinks, update level

Notes:
  Sources enqueued in ascending order by level
  Sinks pushed in descending order by level

new(w):
  Loop:
    While free_list[w].peek().level in cursor: free_list[w].pop()
    If free_list[w] nonempty: return free_list[w].pop()
    If sinks empty: return bump_pointer++
    While sinks nonempty and exist sources of level < sinks.peek().level:
      Dequeue and trace next source
      During tracing:
        If (node to trace).level in cursor and <= source level: stop
        If node to trace == sinks.peek(): pop sink
        If sinks.peek().level in cursor: pop sink
    If sinks nonempty:
      p = pop sink
      for q in p.children:
        free_list[q.w].push(q)
      Return p // first fit
  Return free_list[w].pop()

Notes:
  Need to check if free list level in cursor because items may be cyclic
  When traversing sources and sinks, skip over Source sinks and Sink sources
  `new` considers sinks and sources in ascending order by level
    Smallest sinks first => less sources to trace to prove unreachability
    Smallest sources first => no redundant tracing per `new`
  All Source sources will have levels (l, n) such that cursor[l] = n
  Source level (l1, n1) <= sink level (l2, n2) if l1 <= l2
    Approximation: perfect tracing need only consider sources whose cursors
    are prefixes of the sink cursor, but don't have whole cursors
  Sink level (l, n) in cursor if l < cursor.len && cursor[l] == n

Problem:
  Unreachable memory can be caught up in a different arena's sinks
  e.g. sinks (list nat) = [Cons x xs], sinks nat = []
       It looks like nat arena needs bump_ptr++, but there is actually a nat
       available. It's just not visible until a request is made to the
       list nat arena.
Solution:
  Global sink list too, along with global source list?
    Still need to know which arena each sink belongs to in order to add to
    proper free list
    Store size in each heap item? If so, then don't even need arenas
    Can just maintain pointers to each size class's free list

Problem:
  Still have to trace garbage, which makes things proportional to total size
  and not just the size of the reachable data
  In general the sinks are annoying to maintain
Solution:
  Compacting collection? Then have to segregate stack and heap pointers...
  And the compacting phase takes time proportional to reachable set, so
  levels would only allow saving some traces
  Bitmap allocation? Can have linked lists of bitmapped size classes.
  It's a linear search but one list per size class => small lists and
  bitmap => can check 64 at once. But then can't use levels to stop tracing
  early anymore...
  Wait...
    If run into any level in cursor while tracing, then:
      1) Found cycle, or
      2) Memory was traced already and has been compacted already
    If can distinguish between these two, can avoid compacting already
    traced & compacted memory.
Mutable update:
  Before *p := e,
    match p.level with
      None: no-op
      Some ((i, _) as l) when l in cursor: ++cursor[i]
  The increment nullifies any marks that could keep p's old value alive.
