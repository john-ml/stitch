\documentclass[10pt]{article}
 
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb,graphicx,multicol,array,algpseudocode,tikz,stmaryrd}
 
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\ox}[1]{\left\llbracket #1\right\rrbracket}
\newcommand{\subst}[3]{#1[#2/#3]}
\newcommand{\cons}[2]{#1::#2}

\newenvironment{problem}[2][]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\begin{document}

\section*{Core search}

\newcommand{\genvar}{\textbf{var}}
\newcommand{\gensym}{\textbf{sym}}
\newcommand{\assert}[1]{\textbf{add }#1}

\newcommand{\searchwith}[2]{{\ox{#2}}_{#1}}
\newcommand{\search}[1]{\searchwith{R}{#1}}
\newcommand{\ccrule}[1]{\ox{#1}_P}
 
\begin{align*}
  P, Q\in \textrm{Atom}& \\
  F, G\in\textrm{Formula} &::= P\mid P\sim Q\mid P\land Q\mid P\lor Q\mid R\to F
                          \mid \forall x. F\mid\exists x. F \\
  R, S\in\textrm{Rule} &::= P\mid R\land S\mid R\lor S
                       \mid F\to R\mid \forall x. R\mid \exists x. R \\
  f, g\in\textrm{Process} &::= \assert P\mid\assert P\sim Q
                          \mid f + g\mid f\times g\\
\\
\gensym &= \textrm{fresh symbol} \\
\genvar &= \textrm{fresh variable} \\
\\
\search F &: \textrm{Process} =\textrm{a search for a proof of }F\textrm{ given }R\\
\search{P} &= \assert P + \search{\ccrule R} \\
\search{P\sim Q} &= \assert P\sim Q \\
\search{F\land G} &= \search F\times\search G \\
\search{F\lor G} &= \search F + \search G \\
\search{S\to F} &= \searchwith{R\land S}{F}\\
\search{\forall x. F} &= \search{\subst F{\gensym}x} \\
\search{\exists x. F} &= \search{\subst F{\genvar}x} \\
\\
\ccrule{R} &:\textrm{Formula} = \textrm{subgoal produced by applying }R\textrm{ to }P \\
\ccrule Q &= (P\sim Q)\lor (Q\to P) \\
\ccrule{R\land S} &= \ccrule R\lor \ccrule S \\
\ccrule{R\lor S} &= \ccrule R\land \ccrule S \\
\ccrule{F\to R} &= F\land\ccrule{R} \\
\ccrule{\forall x. R} &= \ccrule{\subst R{\genvar}x} \\
\ccrule{\exists x. R} &= \ccrule{\subst R{\gensym}x} \\
\end{align*}

\noindent Idea: $R\to P\Longleftarrow\ccrule R$.

\noindent Idea for $\ccrule{R\land S}$: $R\land S\to P \iff (R\to P)\lor(S\to P)
  \Longleftarrow\ccrule R\lor \ccrule S$.

\noindent Idea for $\ccrule{R\lor S}$: $R\lor S\to P \iff (R\to P)\land(S\to P)
  \Longleftarrow\ccrule R\land \ccrule S$.

\noindent Idea for $\ccrule{F\to R}$:
  $(F\to R)\to P \iff (R\to P)\land (F\lor P)
    \Longleftarrow F\land \ccrule R$. \begin{itemize}
\newcommand{\searchto}[1]{\searchwith{F\to R}{#1}}
\item $P$ is dropped because it would lead to useless searches:
  if \[\ccrule{F\to R} = \ccrule R\land(F\lor P)\] then \begin{align*}
  \searchto P
    &= \assert P + \searchto{\ccrule{F\to R}} \\
    &= \assert P + \searchto{\ccrule R\land (F\lor P)} \\
    &= \assert P + \searchto{\ccrule R}\times(\searchto F + \searchto P) \\
\end{align*}

\noindent and the nested $\searchto P$ can't do any better than the original query.

\item In Prolog, $R$ is a conjunction of inference rules of the form
  $\forall  v_1\cdots v_n.  F_1\to\cdots\to F_m\to P$ and this definition
  for $\ccrule{F\to R}$ agrees with SLD resolution.

\end{itemize}

\section*{Solvers}

We want to be able to hook the core search algorithm up to a bunch of 
solvers that can solve constraints over specific domains
(for example, if we hook things up to a solver for equality of
s-expressions using first-order unification, we get Prolog).
Solvers will often have typed variables (e.g. Int vs Bitvector in SMT).
To handle this, extend Formula with $\forall (x:T), F\mid\exists (x:T), F$
and similar for Rule. $T$ can be any expression the solver wants---it's just
a way to pass extra information about a variable to a solver.
\\

\noindent Solvers must support: \begin{itemize}
\item $(\assert P)$ to add constraints
\item \textbf{push}, \textbf{pop} for backtracking
\item At least one of \{\textbf{sat?}, \textbf{unsat?}\}
\item \textbf{zonk} to grab satisfying assignments
\end{itemize}

\noindent Solvers can optionally support the special constraint $(P\sim Q)$
  (presumably some kind of equality).\\

\noindent Solvers can optionally support variables: \begin{itemize}
\item To use $\forall$ rule / $\exists$ goal, need $\genvar$.
\item To use $\exists$ rule / $\forall$ goal, need $\gensym$.
\item In both cases, need substitution $\subst eyx$.
\end{itemize}

\noindent There are two ways in which solvers should be able to communicate
with each other: \begin{enumerate}
\item A constraint in one domain gives rise to constraints in other domains.
  For example, the Prolog constraint
  $(N + 5\in\textrm{SMT})::XS \sim (1\in\textrm{SMT})::nil$ should generate
  the SMT constraint $N + 5 = 1$. To implement this, we can simply
  allow solvers to add constraints to other solvers (e.g. in this case,
  the Prolog unification engine can add the constraint $N + 5 = 1$ to the
  SMT solver). When users define a new domain $D$, they can also specify how
  constraints in $D$ give rise to constraints in other domains.
\item A solver for one domain can request a ``translation'' of a term from another
  domain. For example, suppose an SMT solver is given the constraint
  \[{\underbrace{\left(\int_0^{N+1\in\textrm{SMT}}x^2~\mathrm dx\right)}
     _{\textrm{Mathematica}}} + 1 = M\]
  with a Mathematica expression with an SMT expression in it in it.
  The following exchange allows for the SMT
  solver to extract useful information from the Mathematica expression, even though
  it's from a completely different domain: \begin{itemize}
  \item SMT to Mathematica: what is
    $\displaystyle\int_0^{N+1\in\textrm{SMT}}x^2~\mathrm dx$?
  \item Mathematica to SMT: what is $N+1$?
  \item SMT to Mathematica: $N+1$ is $N'+1$.
  \item Mathematica to SMT:
    $\displaystyle\int_0^{N+1\in\textrm{SMT}}x^2~\mathrm dx
    =\displaystyle\int_0^{N'+1}x^2~\mathrm dx
    = (N'+1)^3/3$ is $(N+1)^3/3$.
  \item SMT adds constraint $(N+1)^3/3 + 1 = M$.
  \end{itemize}

  Notes: \begin{itemize}
  \item The Mathematica expression $(N'+1)^3/3$ got converted into an SMT expression
    $(N+1)^3/3$.
  \item The exchange generated a fresh variable $N'$ and remembered the
    association between $N\in \textrm{SMT}$ and $N'\in\textrm{Mathematica}$.
  \end{itemize}

  These steps work only if the user has defined converters between
  Mathematica and SMT that work this way.
\end{enumerate}

\noindent In the first case, constraints in Prolog are being converted into
constraints in SMT. In the second case, terms are being converted back and
forth between SMT and Mathematica. In both cases, the user has to somehow
specify how all these conversions are supposed to work.
If there are $n$ domains then naively specifying every
conversion requires $O(n^2)$ work. Thankfully things are easier
than that: if there are conversions $g: A\to B$ and $f: B\to C$,
then $f\circ g$ is a conversion $A\to C$,
so computing the transitive closure of user-defined conversions
can automatically derive many others. For example, if the user
specifies conversions $g_i:D_i\to \textrm{SExp}, f_i:\textrm{SExp}\to D_i$
to/from a domain called SExp
(which has no nontrivial constraint solving ability of its own)
for each of $n$ domains $D_1,\dots,D_n$, we can automatically derive
conversions to/from each pair of domains: for all $i, j\in\{1,\dots,n\}$,
$f_j\circ g_i:D_i\to D_j$.

\end{document}
