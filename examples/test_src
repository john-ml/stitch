quadruple(x int) int:
  y: int = x + x;
  z: int = x * 2;
  y + z

octuple(z int) int:
  z: int = quadruple(x);
  z + z

deref(p *int) int: *p

index(p **int, i int) int: p[i][i]

dup(x int) {l int, r int}:
  {l = x, r = x}

proj[R](p {x int; R}) int: p.x

inl[C](x int) <l int; C>:
  l@x

inr[C](x int) <r int; C>:
  r@x

nested(x int) int:
  y: int = (
    z: int = x + x;
    z := z + 2;
    z
  );
  y + y

main(argc int, argv **char) void:
  print("hello, world\n")

extract(xy <l int, r int>) int:
  res: int =
    case xy
    | l@x -> x
    | r@y -> y
    end;
  res

quadruple(x):
  y = x + x;
  z = x * 2;
  y + z

octuple(z):
  z = quadruple(x);
  z + z

deref(p): *p

index(p, i): p[i][i]

dup(x):
  {l = x, r = x}

proj(p): p.x

inl(x):
  l@x

inr(x):
  r@x

nested(x):
  y = (
    z = x + x;
    z := z + 2;
    z
  );
  y + y

extract(xy):
  res =
    case xy
    | l@x -> x
    | r@y -> y
    end;
  res

extract(xy):
  case xy
  | l@x -> x
  | r@y -> y
  end

# plus[Num A, Num B](p {x A, y B}, q {x A, y B}) {x A, y B}:
#   {x = p.x + q.x, y = p.y + q.y}

# trait[A](Eq A):
#   __eq__ (A, A) -> bool

# trait[Eq A](Ord A):
#   cmp (A, A) -> <lt, eq, gt>

# impl(Eq i32):
#   __eq__(a, b):
#      a == b

# impl[Eq A, Eq B](Eq {0 A, 1 B}):
#   __eq__(a, b):
#     a.0 == b.0 && a.1 == b.1

# impl[Eq A, Eq R](Eq {A; R}):
#   __eq__(
